# 1. 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다

## 학술적 의미의 함수형 프로그래밍

- 수학 함수를 사용하고 부수효과를 피하는 것이 특징인 프로그래밍 패러다임
- 부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일

## 그러나 실용적 측면에서의 함수형 프로그래밍은

학술적 의미와 달리 부수 효과와 순수하지 않은 함수를 사용함

- 부수효과가 없는 소프트웨어는 의미가 없음 (예: 화면 출력, DB 저장, 네트워크 통신 등)
- 함수형 프로그래밍으로 부수 효과를 더 잘 다룰 수 있음 - 완전히 제거가 아닌, 관리와 격리가 목표

## 액션과 계산, 데이터 구분하기

### 액션 (Actions)

- 실행 시점과 횟수에 의존하는 코드
- 부수 효과가 있는 함수
- 호출 시점과 횟수가 중요하기 때문에 같은 함수를 두 번 호출하면 다른 결과가 나올 수 있음
- 예: 이메일 보내기, DB 저장, API 호출, 현재 시간 읽기

### 계산 (Calculations)

- 입력값으로 출력값을 계산하는 순수 함수
- 같은 입력에 대해 항상 같은 출력을 보장
- 부수 효과가 없음
- 테스트하기 쉽고, 재사용 가능하며, 이해하기 쉬움
- 예: 숫자 더하기, 문자열 결합, 배열 필터링

### 데이터 (Data)

- 이벤트에 대한 사실
- 존재 자체로 의미가 있음 - 해석만 필요
- 가장 다루기 쉬움 - 직렬화 가능, 네트워크 전송 가능, 저장 가능
- 예: 숫자, 문자열, 객체, 배열

## 구분했을 때의 장점

- 액션을 최소화하고 계산과 데이터로 분리하면 코드가 단순해짐
- 액션을 격리해 테스트 범위를 최소화하면 계산은 입출력만 검증하면 되므로 테스트가 쉬워짐
- 액션은 격리되어 있어 다른 코드에 영향을 주지 않음
- 부수 효과가 명확히 구분되어 예측 가능한 코드 작성
- 어떤 코드가 외부에 영향을 주는지 명확히 알 수 있어 유지보수가 용이해짐

## 일급 추상 (First-class Abstractions)

- 일급 값(First-class value): 변수에 할당하고, 함수의 인자로 전달하고, 반환할 수 있는 값
- 일급 함수(First-class function): 함수를 값처럼 다룰 수 있음
  - 함수를 변수에 할당
  - 함수를 다른 함수의 인자로 전달 (콜백, 고차 함수)
  - 함수에서 함수를 반환
- 일급 추상의 장점:
  - 반복되는 패턴을 함수로 추상화 가능
  - 코드 중복 제거
  - 더 높은 수준의 추상화로 복잡도 관리

# 2장. 현실에서의 함수형 사고

## 계층형 설계 (Stratified Design)

- 소프트웨어를 여러 계층으로 구성하는 설계 방식
- 아래 계층은 잘 변하지 않고 상위 계층은 변화에 대응 가능해야함
- 상위 계층은 하위 계층을 사용하지만, 하위 계층은 상위 계층을 몰라야 함

```jsx
[최상위] 비즈니스 규칙 계층
   ↓
[중간] 도메인 계층
   ↓
[하위] 유틸리티/언어 기능 계층
```

### 계층형 설계의 장점

- 한 계층의 변경이 다른 계층에 영향을 주지 않기 때문에 각 계층을 독립적으로 수정 가능
- 하위 계층의 함수들은 여러 상위 계층에서 재사용 가능
- 각 계층별 독립적으로 테스트 가능
- 각 함수가 어느 추상화 수준에 있는지 명확

### 계층형 설계 원칙

- 같은 계층의 함수들은 비슷한 추상화 수준을 가져야 함
- 각 함수는 자신보다 낮은 계층의 함수만 호출해야 함
- 호출 그래프가 순환하지 않아야 함 (A가 B를 호출하면, B는 A를 호출하면 안 됨)

## 타임라인 다이어그램 (Timeline Diagram)

액션들이 시간 순서대로 어떻게 실행되는지 보여주는 다이어그램

```jsx
타임라인 1        타임라인 2
   |                |
[액션A]           [액션C]
   |                |
[액션B]           [액션D]
   |                |
    \              /
     \            /
      \          /
        [액션E]
```

### 타임라인 다이어그램으로 파악할 수 있는 것

1. 실행 순서 파악
   - 어떤 액션이 먼저 실행되는가?
   - 어떤 액션들이 동시에 실행될 수 있는가?
2. 경쟁 조건(Race Condition) 발견
   - 두 타임라인이 같은 자원에 접근할 때 문제 발생 가능
   - 실행 순서에 따라 결과가 달라지는 버그 발견
3. 순서 보장이 필요한 지점 식별
   - 어디서 동기화가 필요한가?
   - 어떤 액션은 반드시 다른 액션 이후에 실행되어야 하는가?

## 고차 동작 (Higher-Order Operations)

타임라인을 다루기 위한 재사용 가능한 패턴을 함수로 만드는 것

### 고차 함수(Higher-Order Function)란?

- 함수를 인자로 받거나 함수를 리턴하는 함수
- 반복되는 패턴을 추상화하여 재사용

### 고차 함수 예시

- map

  ```jsx
  const prices = items.map((item) => item.price);
  ```

- filter

  ```jsx
  const expensiveItems = items.filter((item) => item.price > 100);
  ```

- reduce

  ```jsx
  const total = prices.reduce((sum, price) => sum + price, 0);
  ```

### 타임라인 제어를 위한 고차 동작 예시

- debounce: 함수를 감싸서 타임라인 실행 횟수를 제어

  ```jsx
  // debounce
  const searchDebounced = debounce(search, 300);

  input.addEventListener("input", searchDebounced);
  ```

- queue: 함수를 순차 실행 보장

  ```jsx
  function makeQueue() {
    let queue = [];
    let isRunning = false;

    return function (action) {
      queue.push(action);
      if (!isRunning) {
        runQueue();
      }
    };
  }
  ```

### 장점

- 반복되는 타임라인 패턴을 한 번만 작성
- 검증된 고차 함수를 재사용하므로 안전
- `map`, `filter` 같은 이름으로 의도가 분명해짐
- 고차 함수 자체를 독립적으로 테스트 가능

## 세 가지 기술의 관계

1. 계층형 설계: 코드를 어떻게 구조화할 것인가? (정적 구조)
2. 타임라인 다이어그램: 액션들이 언제 어떻게 실행되는가? (동적 흐름 분석)
3. 커팅: 복잡한 액션을 어떻게 관리 가능한 크기로 나눌 것인가? (복잡도 관리)

# 느낀점

- JavaScript는 배울 때 함수형 언어라고 알고있는데, 책에서는 해당 언어가 부족한 부분이 있다고 얘기한다. 어떤 부분일지 궁금하다 💭
- 액션과 계산을 모두 분리한다는 것이 현실적으로 가능한일 일까 ? 또 이에 따른 성능적인 이슈는 없을지 ?

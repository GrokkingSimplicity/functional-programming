# 17. 타임라인 조율하기
> <i>멀티스레드를 지원하는 언어에서는 스레드를 조율하기 위해 원자적 업데이트 같은 것을 사용해야 합니다. (p.502) </i>

<br/>

원자적 업데이트: 완전이 성공하거나, 완전히 실패하는 것 둘 중 하나만 가능

> <i>간단한 프로그램에서 암묵적 시간 모델은 좋습니다. 하지만 실행 방식을 바꾸지 못합니다. 사실 암묵적 시간 모델의 실행 방식이 애플리케이션에서 필요한 실행 방식과 딱 맞을 일은 거의 없습니다. (p.503) </i>

<br/>

실제 개발에선 프레임 워크가 가지고 있는 기본 실행 모델에만 의존할 수 없게 되는 경우가 많기 때문에 언제나 문제를 해결하기 위한 고민이 필요하다.

# 18. 반응형 아키텍처와 어니언 아키텍처

> <i>반응형 아키텍처의 핵심 원칙은 이벤트에 대한 반응으로 일어날 일을 지정하는 것입니다. 반응형 아키텍처는 웹 서비스와 UI에 잘 어울립니다. (p.512)</i>

<br/>

> <i>반응형 아키텍처는 코드에 나타난 순차적 액션의 순서를 뒤집습니다. X를 하고 Y를 하는 대신, X가 일어나면 언제나 Y를 합니다. 이렇게 하면 코드를 읽기 쉽고 유지보수하기도 좋습니다.
> - 원인과 효과가 결합한 것을 분리합니다.
> - 여러 단계를 파이프라인으로 처리합니다.
> - 타임라인이 유연해집니다. (p.513)</i>

<br/>

반응형 아키텍처에 대한 설명 정리

> <i>셀을 변경할 수 있지만 변경 불가능한 변수에 값을 담아두기 때문에 전역변수보다 더 안전합니다. (p.518)</i>

<br/>

> <i>ValueCell은 다른 타임라인에서 읽거나 쓰는 순서를 보장하지 않습니다. 하지만 어떤 값이 저장되어도 그 값이 항상 올바른 값이라는 것을 보장합니다. (p.518)</i>

<br/>

ValueCell을 보면서 클로저가 떠올랐다. 결국 클로저로 변수를 캡슐화해서 직접 접근을 막고, 정해진 인터페이스(val, update)로만 접근하게 막음으로서 안전하게 전역변수를 공유할 수 있게 됐다.

> <i>문제가 없는데 이 방법으로 분리하는 것은 좋지 않습니다. 코드에 액션을 순서대로 표현하는 것이 더 명확할 수 있습니다. 장바구니처럼 원인과 효과의 중심이 없다면 분리하지 마세요. (p.521)</i>

<br/>

> <i>만약 여러 단계가 있지만 데이터를 전달하지 않는다면 이 패턴을 사용하지 않는 것이 좋습니다. 데이터를 전달하지 않으면 파이프라인이라고 볼 수 없습니다. 따라서 올바른 반응형 아키텍처가 될 수 없습니다. (p.522)</i>

<br/>

설계 패턴은 늘 어떤 순간에 어떤 방식으로 적용할지는 개발자에게 달려있다. 하나의 이론을 무조건적으로 적용하기 보단 상황에 대한 적절한 판단이 중요하다.

> <i>데이터베이스는 변경 가능하고 접근하는 모든 것을 액션으로 만든다는 것이 핵심입니다. (p.531)</i>

<br/>

> <i>어니언 아키텍처는 데이터 베이스나 API 호출과 같은 외부 서비스를 바꾸기 쉽습니다. 가장 높은 계층에서 사용하기 때문입니다. 도메인 계층은 외부 서비스에 의존하지 않아서 테스트하기 좋습니다. 어니언 아키텍처는 좋은 인프라보다 좋은 도메인을 강조합니다. (p.532)</i>

<br/>



> <i>도메인 규칙은 도메인 용어를 사용합니다.
> 1. 도메인 규칙은 도메인 용어를 사용합니다.
> 2. 가독성과 어울리는지 따져봐야 합니다. (p.534)</i>

실무에서 사용하는 FSD 설계 방식이 생각났다. 설계 구조를 잡는 기준들에 대해 좀 더 고민해볼 수 있고, 이 설계를 선택한 이유에 대해 한번 더 생각해보게 됐다.



# 느낀점
- X가 일어나면 언제나 Y를 한다는 점에서 react의 상태 기반 렌더링이 생각났다. 생각보다 많은 곳에 함수형 이론들이 사용되고 있다는 생각이 들었다. 이에 확장해서 전역 상태를 어떻게 안전하게 관리하고 업데이트할지에 대해 고민하게 된 부분이 좋았다.
- 반응형 아키택처와 어니언 아키텍처의 한계
  - 반응형은 실제 코드의 흐름과 달라 디버깅이 어렵고 순서가 보장 되지 않아 순차적인 작업에는 적합하지 않다.
  - 어니언은 계층이 많아지면 간단한 기능도 여러 파일을 돌아다니며 추적해야하기 때문에 복잡도가 증가한다.
  => 결국 이런 설계 패턴들을 배울 때마다 느끼는 건, 언제 사용해야 할지만큼 언제 사용하지 말아야 할지도 중요하다는 것이다. 문제 상황을 제대로 파악하고 적절한 곳에만 적용해야 좋은 설계가 나온다.

# 책 후기
책에서 다룬 함수형 프로그래밍 내용들이 실무와 개발 전반에 많이 연결되어 있다는 걸 느꼈다. 이론적인 내용보다 실제로 적용 가능한 예시들이 많아서 도움이 됐다. 가벼운 함수형에 대해 알아봤으니, 이제 좀 더 깊이 있는 내용들도 궁금해졌다. 개인적으론 JS로 되어있어서 이해가 쉽고, 더 흥미로웠던 것 같다!_! ★★★★★
  


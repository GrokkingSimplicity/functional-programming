# 공유할 내용
> <i>함수의 동작을 바꿨기 때문에 엄밀히 말하면 리팩터링이라고 할 수 없습니다.(p.89)</i>

보통 리팩터링이라고 하면 신규 라이브러리 마이그레이션, 동작 개선 등에도 사용하기도 하는데 리팩터링의 정의를 다시 생각하게 됐다.

<br/>

> <i>인자가 아닌 모든 입력은 암묵적 입력이고 리턴값이 아닌 모든 출력은 암묵적 출력입니다.(p.91)</i>

> <i>데이터를 바꾸지 않았고 정보를 리턴했기 때문에 읽기입니다!(p.112)</i>

> <i>변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있습니다. 따라서 변경 가능한 데이터를 읽는 것은 액션입니다.(p.131)</i>

> 불변 데이터 구조를 읽는 것은 계산입니다.(p.131)

지난주 스터디에 코드를 보고 얘기를 나누면서 액선/계산을 나눌 때 불명확한 부분이 있었는데, 계산과 액션을 할 수 있는 좀 더 명확한 기준을 알게 됐다.
같이 봤던 코드는 내부에 변경 가능한 Ref, State가 있었는데, 변경 가능한 데이터를 읽는 것만으로도 액션으로 분류한다는 것을 깨달았다.

<br/>

> <i>하지만 .shift() 메서드는 이미 읽기 입니다. 값을 리턴하고 있기 때문입니다. 어떻게 해야할까요? 두 가지 접근 방법이 있습니다.
>   1. 읽기와 쓰기 함수로 각각 분리한다.
>   2. 함수에서 값을 두 개 리턴한다.
>
> 두 가지 접근 방법 모두 살펴보겠습니다. 선택할 수 있다면 첫 번째 접근 방법이 더 좋은 방법입니다. 책임이 확실히 분리되기 때문입니다.(p.122)</i>

보통 hook이나 util을 만들 때 편의를 위해 2번처럼 여러개의 값을 return 하곤 했는데 책임을 명확히 하기 위해 두가지를 분류하는 습관을 들여야 겠다고 생각했다.
재사용성이나, 의도를 파악하는 데도 1번이 더 좋을 것 같다.

<br/>

> <i>불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화하세요.(p.133)</i>

불변 데이터를 사용할 때 최적화에 대한 고민을 안할 수 없었다. 근데 성능을 최대로 사용하여 불변성을 최대한 유지하고 문제가 생겼을 때 개선하는 것이 좋겠다고 생각했다.
불변성을 유지해야하는 코드에 비해 최적화가 필요한 코드는 매우 소수일 것이기 때문이다.

<br/>

> <i>clojure에서 지원하는 불변 데이터구조는 다른 언어에서 참고할 만큼 효율적입니다. 어떻게 효율적일까요? 데이터 구조를 복사를 할 대 최대한 많은 구조를 공유합니다. 그래서 더 적은 메모리를 사용하고 결국 가비지 콜렉터의 부담을 줄여줍니다. 구현은 우리가 한 것과 같은 카피-온-라이트를 기반으로 하고 있습니다.(p.133) </i>

Q. clojure는 어떤 불변 데이터 구조를 가질까 ?    
A. Clojure는 배열을 트리 구조로 관리한다. 데이터를 복사할 때 변경된 부분만 새로 생성하기 때문에 메모리가 절약되고 속도가 향상된다.

```
  원본 배열: [A, B, C, D]
         트리
         /  \
       /      \
     [A,B]   [C,D]

  변경: D를 E로 바꿈
        새 트리
         /  \
       /      \
   [A,B]     [C,E]  ← 이 부분만 새로 생성
     ↑
     └─ 원본과 동일한 메모리 공유!
```

<br/>

> 두 개의 중첩된 데이터 구조가 어떤 참조를 공유한다면 <b>구조적 공유(structual sharing)</b>라고 합니다. 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전합니다. 구조적 공유는 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠릅니다.(p.134)

의미는 익숙했는데 구조적 공유라는 용어는 처음 알게 돼서 정의를 정리했다.

> 원래 코드처럼 항목을 직접 변경하면 불변 데이터가 아닙니다. 배열에 항목은 바뀌지 않지만 배열 항목이 참조하는 값은 바뀝니다. 이렇게 되면 불변 데이터가 아닙니다. 중첩된 모든 데이터 구조가 바뀌지 않아야 불변 데이터라고 할 수 있습니다.
> 이것은 매우 중요한 개념입니다. 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야 합니다.(p.140)

얕은 복사시에는 불변성을 해칠 수 있다는 것을 명심해야겠다.

# 책 읽은 후기
- 1~2에서 궁금했던 js와 함수형이 왜 적합하지 않은지에 대해 함수형은 기본적으로 불변성을 유지하해야하는데 js에서 지원하지 않는 언어인 점도 이유일 수 있겠다는 생각이 들었다.
- 실제 FE에서는 모든 불변성을 유지하기란 어렵지 않나 ? 하는 생각이 들었다.
  - 뒷 파트를에서 불변성과 현실 사이에 조화를 얘기해줄 것 같다 ㅎ_ㅎ
  - react에서 불변성 유지와 그를 위한 최적화를 위해 [immer](https://www.npmjs.com/package/immer?activeTab=dependents) 사용하기(참고 문서: [불변 객체와 immer](https://ui.toast.com/posts/ko_20220217))
  

# 더 좋은 액션 만들기

- 함수의 비즈니스 요구사항에 맞춰 인자를 넘기도록 한다.
- 중복된 코드는 재사용하도록 한다. (code smell 을 줄이자.)

- 단순히 코드 라인수가 적은것 보다는 함수의 크기가 적은게 더 유지보수하기 좋은 지표로 사용될 수 있다. 응집력이 있고 재사용하기 쉽기 때문
- 암묵적 입력과 출력은 적을수록 다른 컴포넌트와 연결되지 않아 재사용하기도, 테스트하기도 좋다.
  - 전역변수 대신에 인자로 변경한다.
- 계층은 엉켜있는 코드를 풀면 자연스럽게 만들어진다.

## 설계는 엉켜있는 코드를 푼다.

- 함수를 사용하면 관심사를 자연스럽게 분리할 수 있다.
- 함수는 인자로 넘기는 값과 그 값을 사용하는 방법을 분리한다. 분리된것은 언제든지 쉽게 조합할 수 있다.
- 함수는 작으면 작을수록 재사용하기 쉽고, 올바른지 아닌지 명확하게 알 수 있어 유지보수하기 쉽다.
- 한가지일만 하기때문에 작은 함수는 테스트하기도 쉽다.

- 특별한 문제가 없어도 꺼낼 것이 있다면 분리하는것이 좋다.

## 함수를 분리해 더 좋은 설계 만들기

```js
//원래 코드

function add_item(cart, name, price) {
  var new_cart = cart.slice();
  new_cart.push({
    name: name,
    price: price,
  });

  return new_cart;
}

add_item(shopping_cart, "shoes", 3.45);

//분리한 코드
function make_cart_itme(name, price) {
  return {
    name: name,
    price: price,
  };
}

function add_item(cart, item) {
  var new_cart = cart.slice();
  new_cart.push(item);

  return new_cart;
}

add_item(shopping_cart, make_cart_item("shoes", 3.45));
```

- item 구조만 알고있는 함수와 cart 구조만 알고있는 함수로 나누면 각각 독립적으로 확장할 수 있다.
  - 배열인 cart를 해시맵 같은 자료 구조로 바꾼다고 할 때 변경해야할 부분이 적다.
- copy-on-write는 함께 두도록 한다.
- add_item은 cart와 item에 특화된 함수가 아니기 때문에 일반적인 배열과 항목을 넘겨도 잘 동작한다.

```js
function add_element_last(array, elem) {
  var new_array = array.slice();
  new_array.push(elem);
  return new_array;
}

function add_item(cart, item) {
  return add_element_last(cart, item);
}
```

- 어디에서나 사용할 수 있는 유틸리티 함수로 사용할 수 있다.
- "비즈니스 규칙"과 "장바구니 규칙"은 분리한다.
  - 비즈니스 규칙은 우리 서비스에서 운영하는 특별한 규칙
  - 장바구니 규칙은 대부분의 전자상거래 서비스에서 사용하는 일반적인 개념
- 비즈니스 규칙과 장바구니 규칙에 모두 속하는 동작이 있을 수 있지만 게층 관점에서 보면 code smell
  - 비즈니스 규칙은 장바구니 구조와 같은 하위 계층보다 빠르게 변경되므로 설계하며 분리해야함

# 불변 동작

- 동작을 읽기, 쓰기, 또는 둘다로 분류한다.

### 읽기

- 데이터를 바꾸지 않고 정보를 꺼내는것
- 데이터가 바뀌지 않기 때문에 다루기 쉽다.
- 인자에만 의존해 정보를 가져오는 읽기 동작이라면 계산

### 쓰기

- 데이터를 변경한다.
- 바뀌는 값은 어디서 사용될지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.
- 불변성의 원칙에 따라 구현한다.
- copy-on-write로 쓰기를 읽기로 바꿀 수 있다.

- 쓰면서 읽는 동작은 읽기와 쓰기 함수로 분리한다.
- 쓰기에서 읽기를 분리하고 쓰기에 카피-온-라이트를 적용해 읽기로 바꾼다.
- 변경 가능한 데이터를 읽는것은 액션이고, 변경 불가능한 데이터를 익는것은 계산이다.

## 불변 데이터 구조는 충분히 빠르다.

- 언제든 최적화 가능하고 개발할 때 예상하기 힘든 병목 지점이 항상 있기 때문에 성능 개선을 할때는 보통 미리 최적화하지 않는다.
- 카비지 콜렉터 성능개선이 꾸준히 되어왔기 때문에 충분히 빠르다.
- 많이 복사한다고 해도 참조만 복사되기 떔누에 생각보다 많이 복사하지 않는다.

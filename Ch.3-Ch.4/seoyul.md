# 액션과 계산, 데이터의 차이를 알기

- 타임라인 다이어그램을 그리고 액션, 계산, 데이터로 나눈다. 그리고 액션을 액션에 숨어있는 다른 액션이나 계산 또는 데이터를 발견하기 위해 나눌 수 있는 만큼 나눈다.
- 계산은 더 작은 계산과 데이터로 나누고 연결한다.
- 데이터는 데이터만 조합할 수 있다.
- 어떤 단계에서 무엇인가 결정해야할 것이 있거나, 계획해서 방법을 찾아야할것 것이 있다면 결정과 계획은 계산이 가능성이 높다.

## 데이터란

- 데이터는 이벤트에 대한 사실로 일어난 일의 결과를 기록한것
- 기본 데이터 타입으로 구현한다.(숫자, 문자, 배열, 객체..)
- 데이터 구조로 의미를 담는다. 순서가 중요하다면 순서가 보장하는 데이터 구조를 사용사고, 데이터 구조로 도메인을 표현할 수 있다.

### 불변성

- 불변 데이터 구조를 만들기 위해 두가지 원칙을 사용한다.

1. copy-on-write: 변경할 때 복사본을 만든다.
2. defensive copy: 보관하려고하는 데이터의 복사본을 만든다.

### 장점

1. 직렬화: 직렬화된 데이터는 전송하거나 디스크에 저장했다가 읽기 쉽다.
2. 동일성 비교: 데이터는 비교하기 쉽다.
3. 자유로운 해석: 데이터는 여러가지 방법으로 해석할 수 있다.

### 단점

- 유연하게 히석할 수 있다는 점은 장점이기도 하지만 해석이 반드시 필요하다는 점은 단점이다.
- 해석하지 않은 데이터는 쓸모없는 바이트일 뿐

## 계산

- 일반적으로 가능한 액션을 쓰지 않고, 계산으로 바꿀 수 있는 액션이 있다면 바꾼다.
- 외부에 영향을 주지 않기 때문에 테스트하기 쉽고, 여러번 테스트해도 문제가 없다.
- 충분히 구현하기 쉽다고 생각되는 시점에서 계산으로 계속 나누는 과정을 멈춘다.
- 자바스크립트에서 계산은 함수로 구현한다. 입력값은 함수 인자, 출력값은 함수의 리턴값이다. 그리고 계산 니용은 함수의 본문
- 같은 입력값을 넣으면 값은 결과값이 나와야함, 호출 횟수도 영향을 주지 않음

### 단점

- 실행하기 전에 어떤 일이 발생할지 알 수 없다.
- 소프트웨어 측면에서 함수를 블랙박스로 입력값으로 실행해야 결과를 알 수 있다.

## 액션

- 데이터를 파악, 계산과 추가 데이터 도출하여 액션으로 모든 기능을 하나로 묶는다.
- 데이터 구하기 > 계산 구현 > 액션 구현
- 소프트웨어를 실행하려는 가장 중요한 이유
- 가능한 액션을 적게 사용하고 작게 만든다. 관련없는 코드는 모두 제거한다.
- 내부에 계산과 데이터만 있고, 가장 바깥쪽에 액션이 있는 구조가 이상적 (어니언 아키텍쳐)
- 호출시점에 의존하는것을 제한한다.

### 최적화

- 실행하기 전에는 아무도 모르기 때문에 미리 최적화를 하는것은 좋지 않다.
- 하지만 사용자가 증가한다면 문제가 생길 수도 있기 떄문에 확장성에 대해 미리 고려하는것이 좋다.
- 추상적인 개념이 바뀌지 않는 한 계산은 바뀌지 않아야한다.
- 액션만을 고쳐서 최적화

### 주의할점

- 코드 안쪽에 액션을 호출하는 작은 코드 하나가 전체로 퍼져나가 전체 프로그램을 액션으로 만들지 않도록 한다. (.55P)

## 테스트하기 쉽게 만들기

- 재사용에는 다른 도메인에서 해당 비즈니스 규칙을 사용하는것도 포함된다.
- 함수형으로 바로 작성하기 어렵다면 일단 절차지향형으로 만든다.
- 테스트를 더 쉽게 하기 위해서는 DOM 업데이트와 비즈니스 규칙은 분리되어야하며, 전역변수가 없어야한다.

### 재사용하기 쉽게 만들기

- 전역변수에 읜존하지 않는다.
- DOM을 사용할 수 있는 곳에서 실행된다고 가정하지 않는다.
- 함수가 결과값을 리턴한다.

## 함수형으로 리팩토링하기

- 입력은 함수가 계산을 하기위한 외부정보, 출력은 함수 밖으로 나오는 정보나 어떤 동작으로 함수를 부르는 이유는 결과가 필요하고 원하는 결과를 얻으려면 입력이 필요하다.
- 인자는 명시적 입력, 리턴값은 명시적 출력이지만 암묵적로 함수로 들어가거나 나오는 정보도 있다.
- 함수에 암묵적 입력과 출력이 있으면 액션이 되기 때문에 둘을 없애면 계산이 된다.
- 암묵적 입력은 함수의 인자로 바꾸고, 암묵적 출력은 함수의 리턴값으로 바꾼다.

- 명시적 입력: 인자
- 암묵적 입력: 인자 외 다른 입력 (전역변수 읽기)
- 명시적 출력: 리턴값
- 암묵적 출력: 리턴값 외 다른 출력 (전역변수 바꾸기)

1. 서브 루틴 추출하기

- 기존 코드에서 동작은 바뀌지 않는다.

2. 입력과 출력이 있는 확인

- 전역 변수값을 바꾸는 일은 함수에서 데이터가 나가는 일이기 때문에 출력
- 전역 변수값을 읽는 일은 데이터가 함수 안으로 들어오는 일이기 때문에 입력

3. 암묵적 입력과 출력 제거

- 전역변수 대신 지역변수값을 사용하도록 바꾸로 리턴한다.
  - 원래 함수는 새 함수의 리턴값을 받아 전역변수에 할당
- 전역변수 대신 인자를 만들어 사용한다.
- 불변성을 구현하기 위해 copy-on-write로 복사하여 변경한다.

### 참고할점

- 무조건 더 적은 코드를 지향하기 보다는 테스트하기 쉽고 재사용하기 좋거나 장점이 있다면 괜찮음
- 함수형 프로그래밍으로 구현하면 동시성, 설계, 데이터 모델링 측면에서 장점이 많다.
- 함수형 프로그래밍의 목적은 어떤것을 분리해서 ㅈ더 작게 만들고 테스트하기 쉽고 재상하기 쉽고 이해하기 쉽게 만들기 위함이다. 당장 다른곳에서 쓰지 않더라도 계산으로 분리하는게 좋다.
- 불변값은 생성된 다음에 바뀌면 안되는값으로, 지역변수를 변경하는 곳은 나중에 초기화할 갑승로 새로 생성한다. 그리고 초기화가 끝나면 그 값은 리턴한다.

## 마무리

- 실제 코드 적용은 적어도 6강 혹은 7강까지 본 후 적용 예정, 이전까지는 연습문제 풀기로 진행중
- 어떠한 기준을 갖고 액션, 계산, 데이터를 나눌지 실제 코드로 확인할 수 있어서 추후 실무에 적용해보기 좋을 것 같았음
